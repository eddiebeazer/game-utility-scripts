<?xml version="1.0" encoding="UTF-8"?>
<testsuite errors="0" failures="1" tests="309" skipped="0" time="21.73453140258789" name="Unreal Automation Testing JUnit Test Report" timestamp="2023.01.24-16.41.28">
 <testcase classname="EdgemaulLegends.AttributesComponent.TestOne" name="TestOne" time="0.02188349887728691">
  <failure message="Was expecting true, was false" type="Error">Was expecting true, was false</failure>
 </testcase>
 <testcase classname="Project.Maps.Cycle" name="Cycle" time="19.63868522644043"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding a single block.should result in containing the single block." name="should result in containing the single block." time="0.0052278973162174225"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding a single block.should stay empty when adding zero." name="should stay empty when adding zero." time="0.005915600806474686"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding another structure.should result in the same structure." name="should result in the same structure." time="0.00662820041179657"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding multiple blocks.should combine left adjacent blocks." name="should combine left adjacent blocks." time="0.004759602248668671"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding multiple blocks.should combine right adjacent blocks." name="should combine right adjacent blocks." time="0.004629600793123245"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when currently an empty structure.when adding multiple blocks.should result in containing each of the blocks." name="should result in containing each of the blocks." time="0.004526600241661072"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine an existing head with second block when exactly filling the gap." name="should combine an existing head with second block when exactly filling the gap." time="0.005118098109960556"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine an existing head with second block when overlapping the gap." name="should combine an existing head with second block when overlapping the gap." time="0.005244698375463486"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine an existing tail with second last block when exactly filling the gap." name="should combine an existing tail with second last block when exactly filling the gap." time="0.0059856995940208435"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine an existing tail with second last block when overlapping the gap." name="should combine an existing tail with second last block when overlapping the gap." time="0.004457801580429077"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when end of second block up to start of second last block." name="should combine blocks when end of second block up to start of second last block." time="0.005048196762800217"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when inside of head up to edge of middle block." name="should combine blocks when inside of head up to edge of middle block." time="0.004606500267982483"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when inside of second block up to inside of second last block." name="should combine blocks when inside of second block up to inside of second last block." time="0.005240201950073242"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when left of head up to edge of middle block." name="should combine blocks when left of head up to edge of middle block." time="0.004903201013803482"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when left of second block up to right of second last block." name="should combine blocks when left of second block up to right of second last block." time="0.00531340017914772"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when overlapping whole structure." name="should combine blocks when overlapping whole structure." time="0.004749201238155365"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when start of head up to edge of middle block." name="should combine blocks when start of head up to edge of middle block." time="0.005143400281667709"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine blocks when start of second block up to end of second last block." name="should combine blocks when start of second block up to end of second last block." time="0.004309698939323425"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine existing blocks when exactly filling the gap." name="should combine existing blocks when exactly filling the gap." time="0.0038174018263816833"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should combine existing blocks when overlapping the gap." name="should combine existing blocks when overlapping the gap." time="0.003816600888967514"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing head with adjacent block." name="should grow left an existing head with adjacent block." time="0.004298098385334015"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing head with fully overlapped block." name="should grow left an existing head with fully overlapped block." time="0.0040025003254413605"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing head with partial overlapped block." name="should grow left an existing head with partial overlapped block." time="0.003779299557209015"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing middle block with adjacent block." name="should grow left an existing middle block with adjacent block." time="0.00425180047750473"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing middle block with fully overlapped block." name="should grow left an existing middle block with fully overlapped block." time="0.004411701112985611"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing middle block with partial overlapped block." name="should grow left an existing middle block with partial overlapped block." time="0.004598699510097504"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing tail with adjacent block." name="should grow left an existing tail with adjacent block." time="0.003852400928735733"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing tail with fully overlapped block." name="should grow left an existing tail with fully overlapped block." time="0.004977799952030182"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow left an existing tail with partial overlapped block." name="should grow left an existing tail with partial overlapped block." time="0.004806801676750183"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow outwards an existing head with fully overlapped block." name="should grow outwards an existing head with fully overlapped block." time="0.00455079972743988"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow outwards an existing middle block with fully overlapped block." name="should grow outwards an existing middle block with fully overlapped block." time="0.0042083971202373505"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow outwards an existing tail with fully overlapped block." name="should grow outwards an existing tail with fully overlapped block." time="0.003884498029947281"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing head with adjacent block." name="should grow right an existing head with adjacent block." time="0.0037203021347522736"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing head with fully overlapped block." name="should grow right an existing head with fully overlapped block." time="0.003573000431060791"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing head with partial overlapped block." name="should grow right an existing head with partial overlapped block." time="0.004288099706172943"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing middle block with adjacent block." name="should grow right an existing middle block with adjacent block." time="0.004112701863050461"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing middle block with fully overlapped block." name="should grow right an existing middle block with fully overlapped block." time="0.003733299672603607"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing middle block with partial overlapped block." name="should grow right an existing middle block with partial overlapped block." time="0.004083499312400818"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing tail with adjacent block." name="should grow right an existing tail with adjacent block." time="0.004376601427793503"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing tail with fully overlapped block." name="should grow right an existing tail with fully overlapped block." time="0.0045803003013134"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should grow right an existing tail with partial overlapped block." name="should grow right an existing tail with partial overlapped block." time="0.004067599773406982"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should ignore zero size block in empty space." name="should ignore zero size block in empty space." time="0.004710499197244644"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should ignore zero size block left of head." name="should ignore zero size block left of head." time="0.004243399947881699"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should ignore zero size block right of tail." name="should ignore zero size block right of tail." time="0.004517797380685806"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should insert a new head." name="should insert a new head." time="0.005293097347021103"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should insert a new middle block." name="should insert a new middle block." time="0.004611600190401077"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should insert a new tail." name="should insert a new tail." time="0.003701400011777878"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing head from inside to right edge." name="should swallow a block enclosed in existing head from inside to right edge." time="0.004318200051784515"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing head from left edge to inside." name="should swallow a block enclosed in existing head from left edge to inside." time="0.00422460213303566"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing middle block from inside to right edge." name="should swallow a block enclosed in existing middle block from inside to right edge." time="0.003980502486228943"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing middle block from left edge to inside." name="should swallow a block enclosed in existing middle block from left edge to inside." time="0.0034799985587596893"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing tail from inside to right edge." name="should swallow a block enclosed in existing tail from inside to right edge." time="0.004901200532913208"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block enclosed in existing tail from left edge to inside." name="should swallow a block enclosed in existing tail from left edge to inside." time="0.004008598625659943"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block fully enclosed in existing head." name="should swallow a block fully enclosed in existing head." time="0.003930099308490753"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block fully enclosed in existing middle block." name="should swallow a block fully enclosed in existing middle block." time="0.004964202642440796"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block fully enclosed in existing tail." name="should swallow a block fully enclosed in existing tail." time="0.004877801984548569"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block perfectly matching an existing head." name="should swallow a block perfectly matching an existing head." time="0.00446150079369545"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block perfectly matching an existing middle block." name="should swallow a block perfectly matching an existing middle block." time="0.004507102072238922"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.should swallow a block perfectly matching an existing tail." name="should swallow a block perfectly matching an existing tail." time="0.0050445012748241425"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.when adding a different structure with no overlap.should result in the combined structure." name="should result in the combined structure." time="0.004541799426078796"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.when adding a different structure with some overlap.should result in the combined structure." name="should result in the combined structure." time="0.004547301679849625"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromEnd.when some blocks already exist.when adding another structure the same.should result in the same structure." name="should result in the same structure." time="0.0053842999041080475"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding a single block.should result in containing the single block." name="should result in containing the single block." time="0.004739698022603989"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding a single block.should stay empty when adding zero." name="should stay empty when adding zero." time="0.004533000290393829"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding another structure.should result in the same structure." name="should result in the same structure." time="0.004302900284528732"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding multiple blocks.should combine left adjacent blocks." name="should combine left adjacent blocks." time="0.004775401204824448"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding multiple blocks.should combine right adjacent blocks." name="should combine right adjacent blocks." time="0.004945699125528336"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when currently an empty structure.when adding multiple blocks.should result in containing each of the blocks." name="should result in containing each of the blocks." time="0.003931999206542969"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine an existing head with second block when exactly filling the gap." name="should combine an existing head with second block when exactly filling the gap." time="0.003805398941040039"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine an existing head with second block when overlapping the gap." name="should combine an existing head with second block when overlapping the gap." time="0.004203200340270996"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine an existing tail with second last block when exactly filling the gap." name="should combine an existing tail with second last block when exactly filling the gap." time="0.00391479954123497"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine an existing tail with second last block when overlapping the gap." name="should combine an existing tail with second last block when overlapping the gap." time="0.003681998699903488"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when end of second block up to start of second last block." name="should combine blocks when end of second block up to start of second last block." time="0.0036882013082504272"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when inside of head up to edge of middle block." name="should combine blocks when inside of head up to edge of middle block." time="0.004312701523303986"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when inside of second block up to inside of second last block." name="should combine blocks when inside of second block up to inside of second last block." time="0.004470203071832657"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when left of head up to edge of middle block." name="should combine blocks when left of head up to edge of middle block." time="0.004178699105978012"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when left of second block up to right of second last block." name="should combine blocks when left of second block up to right of second last block." time="0.004183098673820496"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when overlapping whole structure." name="should combine blocks when overlapping whole structure." time="0.004295997321605682"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when start of head up to edge of middle block." name="should combine blocks when start of head up to edge of middle block." time="0.004392001777887344"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine blocks when start of second block up to end of second last block." name="should combine blocks when start of second block up to end of second last block." time="0.00366239994764328"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine existing blocks when exactly filling the gap." name="should combine existing blocks when exactly filling the gap." time="0.003975998610258102"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should combine existing blocks when overlapping the gap." name="should combine existing blocks when overlapping the gap." time="0.004240699112415314"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing head with adjacent block." name="should grow left an existing head with adjacent block." time="0.003928802907466888"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing head with fully overlapped block." name="should grow left an existing head with fully overlapped block." time="0.003867201507091522"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing head with partial overlapped block." name="should grow left an existing head with partial overlapped block." time="0.00456630066037178"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing middle block with adjacent block." name="should grow left an existing middle block with adjacent block." time="0.00456869974732399"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing middle block with fully overlapped block." name="should grow left an existing middle block with fully overlapped block." time="0.004258997738361359"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing middle block with partial overlapped block." name="should grow left an existing middle block with partial overlapped block." time="0.004238799214363098"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing tail with adjacent block." name="should grow left an existing tail with adjacent block." time="0.004725001752376556"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing tail with fully overlapped block." name="should grow left an existing tail with fully overlapped block." time="0.003984697163105011"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow left an existing tail with partial overlapped block." name="should grow left an existing tail with partial overlapped block." time="0.004228603094816208"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow outwards an existing head with fully overlapped block." name="should grow outwards an existing head with fully overlapped block." time="0.004023998975753784"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow outwards an existing middle block with fully overlapped block." name="should grow outwards an existing middle block with fully overlapped block." time="0.004110898822546005"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow outwards an existing tail with fully overlapped block." name="should grow outwards an existing tail with fully overlapped block." time="0.003992002457380295"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing head with adjacent block." name="should grow right an existing head with adjacent block." time="0.0038763992488384247"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing head with fully overlapped block." name="should grow right an existing head with fully overlapped block." time="0.004374600946903229"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing head with partial overlapped block." name="should grow right an existing head with partial overlapped block." time="0.003922298550605774"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing middle block with adjacent block." name="should grow right an existing middle block with adjacent block." time="0.00461219996213913"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing middle block with fully overlapped block." name="should grow right an existing middle block with fully overlapped block." time="0.0050085000693798065"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing middle block with partial overlapped block." name="should grow right an existing middle block with partial overlapped block." time="0.004587497562170029"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing tail with adjacent block." name="should grow right an existing tail with adjacent block." time="0.004641100764274597"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing tail with fully overlapped block." name="should grow right an existing tail with fully overlapped block." time="0.004138600081205368"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should grow right an existing tail with partial overlapped block." name="should grow right an existing tail with partial overlapped block." time="0.00462070107460022"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should ignore zero size block in empty space." name="should ignore zero size block in empty space." time="0.004296600818634033"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should ignore zero size block left of head." name="should ignore zero size block left of head." time="0.004486799240112305"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should ignore zero size block right of tail." name="should ignore zero size block right of tail." time="0.003881402313709259"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should insert a new head." name="should insert a new head." time="0.003971699625253677"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should insert a new middle block." name="should insert a new middle block." time="0.004308801144361496"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should insert a new tail." name="should insert a new tail." time="0.003805100917816162"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing head from inside to right edge." name="should swallow a block enclosed in existing head from inside to right edge." time="0.004003603011369705"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing head from left edge to inside." name="should swallow a block enclosed in existing head from left edge to inside." time="0.004132099449634552"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing middle block from inside to right edge." name="should swallow a block enclosed in existing middle block from inside to right edge." time="0.0042906999588012695"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing middle block from left edge to inside." name="should swallow a block enclosed in existing middle block from left edge to inside." time="0.004226699471473694"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing tail from inside to right edge." name="should swallow a block enclosed in existing tail from inside to right edge." time="0.003814198076725006"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block enclosed in existing tail from left edge to inside." name="should swallow a block enclosed in existing tail from left edge to inside." time="0.004090301692485809"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block fully enclosed in existing head." name="should swallow a block fully enclosed in existing head." time="0.004145801067352295"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block fully enclosed in existing middle block." name="should swallow a block fully enclosed in existing middle block." time="0.004034999758005142"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block fully enclosed in existing tail." name="should swallow a block fully enclosed in existing tail." time="0.004345599561929703"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block perfectly matching an existing head." name="should swallow a block perfectly matching an existing head." time="0.004636302590370178"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block perfectly matching an existing middle block." name="should swallow a block perfectly matching an existing middle block." time="0.004383798688650131"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.should swallow a block perfectly matching an existing tail." name="should swallow a block perfectly matching an existing tail." time="0.0041434988379478455"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.when adding a different structure with no overlap.should result in the combined structure." name="should result in the combined structure." time="0.004241999238729477"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.when adding a different structure with some overlap.should result in the combined structure." name="should result in the combined structure." time="0.00383559986948967"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Add.when called with FromStart.when some blocks already exist.when adding another structure the same.should result in the same structure." name="should result in the same structure." time="0.00467190146446228"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Assignment Operator.when copying an empty structure.should create an empty structure." name="should create an empty structure." time="0.004440397024154663"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Assignment Operator.when some blocks already exist.should create an equal structure." name="should create an equal structure." time="0.004262600094079971"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Assignment Operator.when some blocks already exist.should not share memory." name="should not share memory." time="0.004739001393318176"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Constructor.when copying an empty structure.should create an empty structure." name="should create an empty structure." time="0.004538200795650482"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Constructor.when some blocks already exist.should create an equal structure." name="should create an equal structure." time="0.003790702670812607"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Copy Constructor.when some blocks already exist.should not share memory." name="should not share memory." time="0.004375100135803223"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Empty.when currently an empty structure.should stay as an empty structure." name="should stay as an empty structure." time="0.0044026002287864685"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Empty.when some blocks already exist.should become an empty structure." name="should become an empty structure." time="0.004198599606752396"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetHead.when currently an empty structure.should return nullptr." name="should return nullptr." time="0.004131898283958435"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetHead.when some blocks already exist.should return the ptr to the head block." name="should return the ptr to the head block." time="0.004546500742435455"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetHead.when some blocks already exist.should return valid ptr." name="should return valid ptr." time="0.004356101155281067"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetTail.when currently an empty structure.should return nullptr." name="should return nullptr." time="0.004209399223327637"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetTail.when some blocks already exist.should return the ptr to the head block." name="should return the ptr to the head block." time="0.003934599459171295"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.GetTail.when some blocks already exist.should return valid ptr." name="should return valid ptr." time="0.0038367994129657745"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with a single matching block.should return a structure with the single matching block." name="should return a structure with the single matching block." time="0.004251599311828613"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with every block slightly grown.should return a structure with every original block." name="should return a structure with every original block." time="0.004662800580263138"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with every block slightly shrunk.should return a structure with every block slightly shrunk." name="should return a structure with every block slightly shrunk." time="0.004899401217699051"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with just the same head.should return a structure with just the same head." name="should return a structure with just the same head." time="0.005116600543260574"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with just the same tail.should return a structure with just the same tail." name="should return a structure with just the same tail." time="0.004831600934267044"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given a structure with start and end overlaps for all blocks.should return a structure with just the start and end bytes." name="should return a structure with just the start and end bytes." time="0.004873201251029968"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given an fully overlapping structure.should return a structure of the same blocks." name="should return a structure of the same blocks." time="0.0061514005064964294"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given an inverted structure.should return an empty structure." name="should return an empty structure." time="0.0048810988664627075"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when given the same structure.should return a structure of the same blocks." name="should return a structure of the same blocks." time="0.0055723972618579865"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Intersect.when the given an empty structure.should return an empty structure." name="should return an empty structure." time="0.004761800169944763"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Assignment Operator.when moving from a non-empty structure.should become a structure with same data." name="should become a structure with same data." time="0.004503998905420303"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Assignment Operator.when moving from a non-empty structure.should make source an empty structure." name="should make source an empty structure." time="0.004509501159191132"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Assignment Operator.when moving from a non-empty structure.should take memory ownership." name="should take memory ownership." time="0.0045365020632743835"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Assignment Operator.when moving from an empty structure.should become an empty structure." name="should become an empty structure." time="0.004409000277519226"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Assignment Operator.when moving from an empty structure.should leave source as an empty structure." name="should leave source as an empty structure." time="0.005226701498031616"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Constructor.when currently an empty structure.should create an empty structure." name="should create an empty structure." time="0.0053662993013858795"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Constructor.when currently an empty structure.should leave source as an empty structure." name="should leave source as an empty structure." time="0.006291501224040985"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Constructor.when some blocks already exist.should create a structure with same data." name="should create a structure with same data." time="0.0052390992641448975"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Move Constructor.when some blocks already exist.should leave source as an empty structure." name="should leave source as an empty structure." time="0.005144000053405762"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when currently an empty structure.when removing a block.should result in empty structure." name="should result in empty structure." time="0.005372501909732819"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when currently an empty structure.when removing another structure.should result in empty structure." name="should result in empty structure." time="0.0057954005897045135"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore block after tail." name="should ignore block after tail." time="0.004356499761343002"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore block before head." name="should ignore block before head." time="0.004249799996614456"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore block inside gap." name="should ignore block inside gap." time="0.00476599857211113"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore zero size block on head." name="should ignore zero size block on head." time="0.0048993974924087524"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore zero size block on middle block." name="should ignore zero size block on middle block." time="0.004476003348827362"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should ignore zero size block on tail." name="should ignore zero size block on tail." time="0.004633001983165741"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove all blocks with exact overlap." name="should remove all blocks with exact overlap." time="0.0045012980699539185"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove all blocks with extra overlap." name="should remove all blocks with extra overlap." time="0.004389896988868713"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove block when exact match." name="should remove block when exact match." time="0.005505502223968506"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove block when overlapping." name="should remove block when overlapping." time="0.0045458003878593445"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove head when exact match." name="should remove head when exact match." time="0.004405397921800613"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove head when overlapping." name="should remove head when overlapping." time="0.004236198961734772"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove tail when exact match." name="should remove tail when exact match." time="0.003929298371076584"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should remove tail when overlapping." name="should remove tail when overlapping." time="0.004219502210617065"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink end of block." name="should shrink end of block." time="0.004092499613761902"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink end of head." name="should shrink end of head." time="0.0041319988667964935"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink end of tail." name="should shrink end of tail." time="0.004693802446126938"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink semi overlapped blocks, removing fully overlapped block." name="should shrink semi overlapped blocks, removing fully overlapped block." time="0.004618201404809952"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink semi overlapped head and tail, removing fully overlapped block." name="should shrink semi overlapped head and tail, removing fully overlapped block." time="0.003997400403022766"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink start of block." name="should shrink start of block." time="0.003860700875520706"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink start of head." name="should shrink start of head." time="0.0043132007122039795"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should shrink start of tail." name="should shrink start of tail." time="0.004803001880645752"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should split block." name="should split block." time="0.004379101097583771"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should split head." name="should split head." time="0.004540696740150452"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.should split tail." name="should split tail." time="0.004681698977947235"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.when removing a different structure with no overlap.should result in the original structure." name="should result in the original structure." time="0.00560230016708374"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.when removing a different structure with some overlap.should result in the chopped structure." name="should result in the chopped structure." time="0.003972500562667847"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromEnd.when some blocks already exist.when removing another structure the same.should result in an empty structure." name="should result in an empty structure." time="0.0038403980433940887"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when currently an empty structure.when removing a block.should result in empty structure." name="should result in empty structure." time="0.004601500928401947"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when currently an empty structure.when removing another structure.should result in empty structure." name="should result in empty structure." time="0.005423396825790405"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore block after tail." name="should ignore block after tail." time="0.004164200276136398"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore block before head." name="should ignore block before head." time="0.0040518008172512054"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore block inside gap." name="should ignore block inside gap." time="0.004120100289583206"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore zero size block on head." name="should ignore zero size block on head." time="0.003972899168729782"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore zero size block on middle block." name="should ignore zero size block on middle block." time="0.003690700978040695"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should ignore zero size block on tail." name="should ignore zero size block on tail." time="0.003795001655817032"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove all blocks with exact overlap." name="should remove all blocks with exact overlap." time="0.0038009993731975555"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove all blocks with extra overlap." name="should remove all blocks with extra overlap." time="0.004445601254701614"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove block when exact match." name="should remove block when exact match." time="0.003954797983169556"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove block when overlapping." name="should remove block when overlapping." time="0.004168599843978882"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove head when exact match." name="should remove head when exact match." time="0.003857199102640152"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove head when overlapping." name="should remove head when overlapping." time="0.003709401935338974"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove tail when exact match." name="should remove tail when exact match." time="0.0036399029195308685"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should remove tail when overlapping." name="should remove tail when overlapping." time="0.003972999751567841"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink end of block." name="should shrink end of block." time="0.004498202353715897"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink end of head." name="should shrink end of head." time="0.0045190006494522095"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink end of tail." name="should shrink end of tail." time="0.003876999020576477"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink semi overlapped blocks, removing fully overlapped block." name="should shrink semi overlapped blocks, removing fully overlapped block." time="0.003719497472047806"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink semi overlapped head and tail, removing fully overlapped block." name="should shrink semi overlapped head and tail, removing fully overlapped block." time="0.00406549870967865"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink start of block." name="should shrink start of block." time="0.0037926025688648224"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink start of head." name="should shrink start of head." time="0.003560401499271393"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should shrink start of tail." name="should shrink start of tail." time="0.003637302666902542"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should split block." name="should split block." time="0.0036683008074760437"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should split head." name="should split head." time="0.003983497619628906"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.should split tail." name="should split tail." time="0.003929600119590759"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.when removing a different structure with no overlap.should result in the original structure." name="should result in the original structure." time="0.0046594999730587006"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.when removing a different structure with some overlap.should result in the chopped structure." name="should result in the chopped structure." time="0.004368700087070465"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.Remove.when called with FromStart.when some blocks already exist.when removing another structure the same.should result in an empty structure." name="should result in an empty structure." time="0.003892596811056137"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply empty structure for selecting nothing, with blank index." name="should supply empty structure for selecting nothing, with blank index." time="0.003943301737308502"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply empty structure for selecting nothing, with intersecting index." name="should supply empty structure for selecting nothing, with intersecting index." time="0.003866199404001236"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply exactly selected entire structure." name="should supply exactly selected entire structure." time="0.004307400435209274"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply exactly selected serial blocks." name="should supply exactly selected serial blocks." time="0.003813602030277252"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply partially selected serial blocks, shrinking head and tail." name="should supply partially selected serial blocks, shrinking head and tail." time="0.0035999007523059845"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply partially selected serial blocks, shrinking two blocks." name="should supply partially selected serial blocks, shrinking two blocks." time="0.004256900399923325"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply partially selected serial blocks, skipping head by adjacent index." name="should supply partially selected serial blocks, skipping head by adjacent index." time="0.004144798964262009"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has enough bytes.should supply single portion of one block." name="should supply single portion of one block." time="0.004173099994659424"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has less bytes than requested.should supply entire structure." name="should supply entire structure." time="0.004172701388597488"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure has less bytes than requested.should supply last part of structure, with intersecting index." name="should supply last part of structure, with intersecting index." time="0.004044998437166214"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure is empty.should not effect OutputStructure." name="should not effect OutputStructure." time="0.003921099007129669"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.SelectSerialBytes.when the structure is empty.should return 0." name="should return 0." time="0.003929499536752701"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.ToString.when the structure has blocks.should return clamped string representation." name="should return clamped string representation." time="0.003917001187801361"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.ToString.when the structure has blocks.should return full string representation." name="should return full string representation." time="0.004504002630710602"></testcase>
 <testcase classname="BuildPatchServices.Unit.BlockStructure.ToString.when the structure is empty.should return empty string." name="should return empty string." time="0.004421301186084747"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChainedChunkSource.Get.when a chunk does not exist in any source.should have called Get on all provided sources." name="should have called Get on all provided sources." time="0.004444699734449387"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChainedChunkSource.Get.when a chunk does not exist in any source.should return nullptr." name="should return nullptr." time="0.003842100501060486"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChainedChunkSource.Get.when a chunk exists in at least one source.should return the correct chunk." name="should return the correct chunk." time="0.004057299345731735"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChainedChunkSource.Get.when a chunk exists in at least one source.should successfully return." name="should successfully return." time="0.003914199769496918"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map has free space.should provide cleanable chunks which have refcount 0." name="should provide cleanable chunks which have refcount 0." time="0.004015699028968811"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map has free space.should provide no chunks if all chunks are referenced." name="should provide no chunks if all chunks are referenced." time="0.004212602972984314"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is exact desired size.should provide cleanable chunks which have refcount 0." name="should provide cleanable chunks which have refcount 0." time="0.0039844997227191925"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is exact desired size.should provide no chunks if all chunks are referenced." name="should provide no chunks if all chunks are referenced." time="0.0042013004422187805"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is full.should provide bootable chunks which are needed the latest." name="should provide bootable chunks which are needed the latest." time="0.004087097942829132"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is full.should provide cleanable chunks over bootable chunks." name="should provide cleanable chunks over bootable chunks." time="0.004261501133441925"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is full.should provide cleanable chunks which have refcount 0." name="should provide cleanable chunks which have refcount 0." time="0.00426119938492775"></testcase>
 <testcase classname="BuildPatchServices.Unit.ChunkEvictionPolicy.Query.when chunk map is full.should provide minimum number of bootable chunks." name="should provide minimum number of bootable chunks." time="0.004132397472858429"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Construction.should create a chunkdump file at provided path." name="should create a chunkdump file at provided path." time="0.005616400390863419"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Construction.when there are errors opening the chunkdump.should retry until successful." name="should retry until successful." time="0.10995310544967651"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Destruction.should delete the chunkdump file created." name="should delete the chunkdump file created." time="0.005312502384185791"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Destruction.when there are still queued requests.should clean up all queued put memory." name="should clean up all queued put memory." time="0.005064800381660461"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was not previously Put.should not attempt to load some chunk." name="should not attempt to load some chunk." time="0.0051269009709358215"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was previously Put.and LoadFromArchive will be successful.should not load some chunk twice in a row." name="should not load some chunk twice in a row." time="0.00537480041384697"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was previously Put.and LoadFromArchive will not be successful.should only attempt to load some chunk once." name="should only attempt to load some chunk once." time="0.005227100104093552"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was previously Put.and LoadFromArchive will not be successful.should return nullptr." name="should return nullptr." time="0.005052000284194946"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was previously Put.should enforce the reader to have been reopened." name="should enforce the reader to have been reopened." time="0.005493100732564926"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Get.when some chunk was previously Put.should load some chunk from the chunkdump." name="should load some chunk from the chunkdump." time="0.005033597350120544"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Put.should cause the reader to be reopened ready for a Get." name="should cause the reader to be reopened ready for a Get." time="0.0048162005841732025"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Put.should not save some chunk that was previously saved." name="should not save some chunk that was previously saved." time="0.0052030980587005615"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Put.should release chunk data once saved." name="should release chunk data once saved." time="0.005222000181674957"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Put.should save some chunk to the chunkdump." name="should save some chunk to the chunkdump." time="0.0052431002259254456"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was not previously Put.should not attempt to load some chunk." name="should not attempt to load some chunk." time="0.005679700523614883"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was previously Put.and LoadFromArchive will be successful.and when some chunk was last used with Get.should return some chunk without loading it." name="should return some chunk without loading it." time="0.005760598927736282"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was previously Put.and LoadFromArchive will be successful.and when some chunk was last used with Remove.should need to reload some chunk." name="should need to reload some chunk." time="0.005022600293159485"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was previously Put.and LoadFromArchive will not be successful.should only attempt to load some chunk once." name="should only attempt to load some chunk once." time="0.005335099995136261"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was previously Put.and LoadFromArchive will not be successful.should return invalid ptr." name="should return invalid ptr." time="0.0048965997993946075"></testcase>
 <testcase classname="BuildPatchServices.Unit.DiskChunkStore.Remove.when some chunk was previously Put.should load some chunk from the chunkdump." name="should load some chunk from the chunkdump." time="0.005048498511314392"></testcase>
 <testcase classname="BuildPatchServices.Unit.FileAttribution.Abort.should halt process and stop." name="should halt process and stop." time="0.00394580140709877"></testcase>
 <testcase classname="BuildPatchServices.Unit.FileAttribution.ApplyAttributes.when a file is known missing.should skip making calls to set attributes on that file." name="should skip making calls to set attributes on that file." time="0.0038638003170490265"></testcase>
 <testcase classname="BuildPatchServices.Unit.FileAttribution.Construction.should initialize progress to 0." name="should initialize progress to 0." time="0.003596000373363495"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Abort.should abort loading of chunks, reporting IInstallChunkSourceStat::ELoadResult::Aborted." name="should abort loading of chunks, reporting IInstallChunkSourceStat::ELoadResult::Aborted." time="0.01431019976735115"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is in the store.should return some chunk without loading." name="should return some chunk without loading." time="0.013812500983476639"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.should return some chunk loading from disk." name="should return some chunk loading from disk." time="0.014309398829936981"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.when data required for some chunk is corrupt.should fail to load some chunk from disk, reporting IInstallChunkSourceStat::ELoadResult::HashCheckFailed." name="should fail to load some chunk from disk, reporting IInstallChunkSourceStat::ELoadResult::HashCheckFailed." time="0.015112899243831635"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.when some chunk hashes are not known.should not have attempted to load some chunk from disk." name="should not have attempted to load some chunk from disk." time="0.013716500252485275"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.when some chunk sha is not known.should still succeed to load some chunk from disk." name="should still succeed to load some chunk from disk." time="0.013997398316860199"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.when some chunk sha is not known.when data required for some chunk is corrupt.should fail to load some chunk from disk, reporting IInstallChunkSourceStat::ELoadResult::HashCheckFailed." name="should fail to load some chunk from disk, reporting IInstallChunkSourceStat::ELoadResult::HashCheckFailed." time="0.013799399137496948"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is available.when some chunk is not in the store.when upcoming chunk references are known.should also load upcoming chunks according to provided configuration." name="should also load upcoming chunks according to provided configuration." time="0.015396401286125183"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is not available.when some chunk is in the store.should return some chunk." name="should return some chunk." time="0.01382949948310852"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.Get.when some chunk is not available.when some chunk is not in the store.should return nullptr." name="should return nullptr." time="0.014096699655056"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.GetAvailableChunks.when there are no chunks available.should return an empty set." name="should return an empty set." time="0.004159700125455856"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.GetAvailableChunks.when there are some available chunks.should return the available chunks." name="should return the available chunks." time="0.014364302158355713"></testcase>
 <testcase classname="BuildPatchServices.Unit.InstallChunkSource.SetPaused.should delay the chunk load process." name="should delay the chunk load process." time="0.518873393535614"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.DumpToOverflow.when some chunks were previously Put.should Put all chunks to the overflow store." name="should Put all chunks to the overflow store." time="0.004057802259922028"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.DumpToOverflow.when some chunks were previously Put.when a chunks was previously Get.should Put all chunks to the overflow store." name="should Put all chunks to the overflow store." time="0.004123799502849579"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Get.when no chunks were previously Put.should return nullptr for each call." name="should return nullptr for each call." time="0.0038027018308639526"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Get.when some chunks were previously Put.should successfully return some chunks." name="should successfully return some chunks." time="0.004537999629974365"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Get.when some chunks were previously Put.when some chunk was previously Get and Removed.should return nullptr." name="should return nullptr." time="0.004372298717498779"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Get.when some chunks were previously Put.when some chunk was previously Get.should return the chunk." name="should return the chunk." time="0.003916501998901367"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Get.when some chunks were previously Put.when some chunk was previously Removed.should return nullptr." name="should return nullptr." time="0.004508897662162781"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Put.should query the chunk eviction policy." name="should query the chunk eviction policy." time="0.003959100693464279"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Put.when some chunks were previously Put.when there are bootable chunks.should boot them." name="should boot them." time="0.004066798835992813"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Put.when some chunks were previously Put.when there are bootable chunks.should Put them to the overflow store." name="should Put them to the overflow store." time="0.00412369892001152"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Put.when some chunks were previously Put.when there are cleanable chunks.should release them." name="should release them." time="0.0043868012726306915"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Remove.when no chunks were previously Put.should return invalid ptr for each call." name="should return invalid ptr for each call." time="0.004103001207113266"></testcase>
 <testcase classname="BuildPatchServices.Unit.MemoryChunkStore.Remove.when some chunks were previously Put.should return valid ptr for each call." name="should return valid ptr for each call." time="0.0038444995880126953"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.should initially return 0." name="should initially return 0." time="0.004105500876903534"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when paused.then started.and 3 seconds have passed.should return 0." name="should return 0." time="0.004029802978038788"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when paused.then started.and 3 seconds have passed.then stopped.should return 0." name="should return 0." time="0.003806300461292267"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when paused.then started.and 3 seconds have passed.then un-paused.and 2 seconds have passed.should return 2." name="should return 2." time="0.0036863014101982117"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.should return 3." name="should return 3." time="0.0035398975014686584"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then paused.and 2 seconds have passed.should return 3." name="should return 3." time="0.003891199827194214"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then paused.and 2 seconds have passed.then stopped.should return 3." name="should return 3." time="0.003890402615070343"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then paused.and 2 seconds have passed.then un-paused.and 2 seconds have passed.should return 5." name="should return 5." time="0.004014302045106888"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then paused.and 2 seconds have passed.then un-paused.and 2 seconds have passed.then stopped.should return 5." name="should return 5." time="0.0037511028349399567"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then stopped.and 4 seconds have passed.should return 3." name="should return 3." time="0.00417570024728775"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then stopped.and 4 seconds have passed.then started.and 3 seconds have passed.should return 6." name="should return 6." time="0.0038766004145145416"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then stopped.and 4 seconds have passed.then stopped.should return 3." name="should return 3." time="0.0038187988102436066"></testcase>
 <testcase classname="BuildPatchServices.Unit.ProcessTimer.GetSeconds.when started.and 3 seconds have passed.then stopped.should return 3." name="should return 3." time="0.0037541985511779785"></testcase>
 <testcase classname="EdgemaulLegends.AttributesComponent.Testtwo" name="Testtwo" time="0.0022759996354579926"></testcase>
</testsuite>